<!--
同期影響レポート:
- バージョン: なし → 1.0.0 (憲章の初回制定)
- 変更された原則: なし（初回作成）
- 追加されたセクション: 全て（テンプレートから完全な憲章を作成）
- 削除されたセクション: なし
- テンプレートのステータス:
  ✅ plan-template.md: レビュー済み - 互換性あり
  ✅ spec-template.md: レビュー済み - 互換性あり
  ✅ tasks-template.md: レビュー済み - 互換性あり
- フォローアップTODO: なし
- 理由: MINOR版（1.0.0）- ガバナンスフレームワークの初回確立
-->

# sun-riseup-viewrrr 憲章

## 核心原則

### I. 機能ベースアーキテクチャ（必須）

機能は `src/features/[機能名]/` 配下に自己完結したモジュールとして整理し、以下の標準的な内部構造を持たなければなりません：
- `components/` UIコンポーネント用
- `hooks/` Reactフック用
- `types/` TypeScriptインターフェース用
- `stories/` Storybookストーリー用
- `__tests__/` テスト用
- `index.ts` 唯一の公開APIエクスポートポイント

**理由**: モジュール性を維持し、機能間の結合を防ぎ、独立したテストと並行開発を可能にします。明確な境界は認知負荷を減らし、必要に応じて機能をライブラリとして抽出することを可能にします。

**規則**:
- 機能は他の機能の内部モジュールから直接インポートしてはなりません
- 全ての機能のエクスポートは `index.ts` を経由しなければなりません
- 機能間の循環依存は禁止です
- 共有コードは明確な目的を持って `src/shared/` に配置しなければなりません

### II. 型安全性（必須）

TypeScriptの厳格モードを以下の設定で有効にしなければなりません：
- `strict: true`
- `noUnusedLocals: true`
- `noImplicitReturns: true`
- 型インポートは `import type` 構文を使用しなければなりません（Biomeで強制）
- `any` 型は禁止です（Biomeの警告レベル - エラーとして扱う）

**理由**: 実行時エラーを防ぎ、保守性を向上させ、信頼性の高いリファクタリングを可能にします。UIとバックエンドの障害がユーザー体験に影響するクロスプラットフォームアプリケーションでは、型安全性は交渉の余地がありません。

**規則**:
- 全ての関数は明示的な戻り値の型を持たなければなりません
- Propsインターフェースはコンポーネントと同じ場所に定義しなければなりません
- サービスインターフェースは実装前に定義しなければなりません
- コミット前に型チェックが合格しなければなりません

### III. 品質ゲート（必須）

コードの変更をコミットする前に、以下の全てが合格しなければなりません：
```bash
pnpm tauri build   # プロジェクトのフルビルド
pnpm type-check    # TypeScript検証
pnpm lint          # Biomeによるlintチェック
pnpm test          # Vitestテストスイート
```

**理由**: 品質低下やリグレッションを防ぎます。自動化されたゲートはコードレビュー前に問題を検出し、イテレーションサイクルを短縮し、コードベースの健全性を維持します。

**規則**:
- 品質ゲートの失敗 = コミットブロック（例外なし）
- 新しいコードはテストカバレッジを低下させてはなりません
- Lint違反は抑制するのではなく修正しなければなりません
- 本番デプロイメントにはビルド成功が必要です

### IV. テスト容易性のための依存性注入

外部API（Tauri、ファイルシステムなど）は、`src/shared/` で定義されたサービスインターフェースの背後に抽象化しなければなりません：
- サービスは `ServiceContext` から `useServices()` フックを通じてアクセスします
- テストコードは `<ServicesProvider services={mockService}>` を通じてモックサービスを注入しなければなりません
- アダプター層の外でTauri APIを直接呼び出すことは禁止です

**理由**: プラットフォーム依存性なしに包括的なテストを可能にします。バックエンド（Rust）とフロントエンド（React）を独立してテストできることは、クロスプラットフォームアプリにとって重要です。

**規則**:
- 新しい外部依存関係はサービスインターフェースを持たなければなりません
- サービスインターフェースは `src/shared/context/` に配置
- 実装は `src/shared/adapters/` に配置
- テストは `src/test/mocks.ts` に配置
- アダプター層の外で `@tauri-apps/*` のインポートは禁止

### V. テスト戦略

テストピラミッドに従わなければなりません：
1. **単体テスト**: フック、ユーティリティ、純粋関数（Vitest）
2. **統合テスト**: モックサービスを使用した機能レベルの動作（Testing Library）
3. **コンポーネントテスト**: 実装の詳細ではなく、ユーザーインタラクション（Testing Library）

**理由**: カバレッジと保守性のバランスを取ります。単体テストはロジックエラーを早期に検出し、統合テストは機能契約を検証し、コンポーネントテストはUXが機能することを保証します。

**規則**:
- 実装の詳細ではなく、ユーザーの動作をテストします
- Tauri APIは `src/test/mocks.ts` の `setupTauriMocks()` を通じてモックします
- テストはコードと同じ場所の `__tests__/` サブディレクトリに配置しなければなりません
- ビジュアルコンポーネントテストにはStorybook（オプション）を使用

## 技術スタックの制約

### 承認されたスタック

**フロントエンド**:
- React 19（並行機能：`useTransition`、並列レンダリング）
- TypeScript 5.6以上
- Vite 6（バンドリング用）
- Tailwind CSS 4（`@tailwindcss/vite`使用）
- SWR（キャッシュ付きデータフェッチング用）
- shadcn/uiコンポーネント

**バックエンド**:
- Tauri v2（Rust）
- Tauriプラグイン：dialog、fs、opener、store

**テスト**:
- Vitest 3.2以上（jsdom使用）
- @testing-library/react 16
- Playwright（E2Eテスト用、必要に応じて）
- Storybook 9（コンポーネントプレイグラウンド用）

**コード品質**:
- Biome 2.1以上（lintとフォーマット）
- useSortedClasses（Tailwindクラスの並び替え用）

### 技術的制約

- Reactクラスコンポーネントは禁止（関数コンポーネントのみ）
- `useTransition` は画像ナビゲーションに使用してはなりません（UXを低下させる）
- Context APIはDIとテーマ管理のみに使用（グローバル状態管理には使用しない）
- 状態管理のスケーリング：`docs/state-management-analysis.md` に従ってZustandを評価

## 開発ワークフロー

### 変更プロセス（必須）

**変更前**:
1. インターネットソースからライブラリ/APIの使用方法を調査
2. `package.json` の現在のバージョンとの互換性を確認
3. 使用方法が現在のベストプラクティスに従っていることを確認
4. 非互換/非推奨の場合、アプローチ変更の承認を求める

**実装中**:
1. 焦点を絞った段階的な変更を行う
2. コードを自己レビューして品質を確認
3. トレードオフ（メリット/デメリット）を文書化
4. 下流への影響を分析

**実装後**（必須）:
```bash
pnpm type-check    # 合格必須
pnpm lint          # 合格必須
pnpm test          # 合格必須
pnpm build         # 本番変更の場合
```

**問題対応**:
- すぐに修正を試みてはいけません
- まず詳細なステータスを報告
- 指示を待つ
- ロールバックを可能にするため頻繁にコミット

### コードスタイル

**インポート**:
- `src/` インポートには `@/` エイリアスを使用
- 型インポート：`import type { Foo } from 'bar'`
- 機能のインポートはルートから：`@/features/folder-navigation`

**コンポーネント**:
- 関数コンポーネントのみ
- Propsインターフェースはコンポーネントと同じ場所に配置
- フックは `hooks/` サブディレクトリに
- ストーリーは `stories/` サブディレクトリに

**スタイリング**:
- Tailwindクラスのみ（インラインスタイルは使用しない）
- 条件付きクラスには `cn()` ユーティリティを使用
- Biomeがクラスのソートを強制

### よくある落とし穴（回避すべき）

❌ Tauri APIの直接呼び出し（テスト容易性を損なう）  
❌ 画像ナビゲーションでの `useTransition`（UXの低下）  
❌ 機能間の直接インポート（結合）  
❌ `any` 型（安全でない）  
❌ フォルダ変更時の `ImageViewer` key propの省略（状態が古くなる）  
❌ 循環依存  
❌ 品質ゲートなしでのコミット

## ガバナンス

### 憲章の権限

本憲章は、他の全ての慣行、ガイドライン、規約に優先します。矛盾がある場合、憲章の原則が優先されます。

### 修正プロセス

1. PRで根拠とともに修正を提案
2. セマンティックバージョニングに従ってバージョンを更新：
   - **MAJOR**: 原則への破壊的変更（削除、非互換な再定義）
   - **MINOR**: 新しい原則、拡張されたガイダンス、新しいセクション
   - **PATCH**: 明確化、文言修正、非セマンティックな改善
3. ファイル冒頭の同期影響レポートを更新
4. テンプレートの整合性を検証（plan、spec、tasksテンプレート）
5. 原則が日常のワークフローに影響する場合、`.github/copilot-instructions.md` を更新
6. プロジェクトメンテナーの承認が必要

### コンプライアンスレビュー

- 全てのPRは憲章への準拠を検証しなければなりません
- 品質ゲートは自動化されなければなりません（CI/CD）
- 憲章違反は `plan.md` の `Complexity Tracking` セクションで正当化されなければなりません
- 憲章の原則を参照する運用ガイダンスには `.github/copilot-instructions.md` を使用

### ガイダンスファイル

- **運用ガイダンス**: `.github/copilot-instructions.md`（日常の開発）
- **アーキテクチャ決定**: `docs/library-separation-analysis.md`、`docs/menu-action-architecture.md`、`docs/state-management-analysis.md`
- **憲章**: `.specify/memory/constitution.md`（このファイル - ガバナンス）

**バージョン**: 1.0.0 | **承認日**: 2025-10-28 | **最終修正日**: 2025-10-28
